__revision__ = " $Id$ "

import time
import io
import os
import datetime
import random
import math
import pickle
from datetime import (
    date,
    datetime,
    timedelta
)
import toml

from openalea.plantgl.all import (
    Sphere,
    Viewer,
    Box,
    Vector3,
    cross
)

from vmapplet import get_shared_data, constants, optimisation
from vmapplet.output import Data
from vmapplet.colors import Colors
from vmapplet.organs.tree import Tree
from vmapplet.organs.leaf import AppleLeaf
from vmapplet.organs.fruit import AppleFruit
from vmapplet.organs.wood import Wood
from vmapplet.organs.internode import Internode
from vmapplet.organs.apex import ApexData
from vmapplet.tools.simulation import SimulationStocatree
from vmapplet.sequences import Markov, generate_sequence, terminal_fate
from vmapplet.organs.metamer import MetamerData
from vmapplet.organs.growth_unit import GrowthUnitData
from vmapplet.structure_analysis import HiddenSemiMarkov, StatError
from vmapplet.srandom import boolean_event
from vmapplet.physics import rotate_frame_at_branch, rupture
from vmapplet.tools.surface import *
from vmapplet.tools.data_process import Group, Statistics
from vmapplet.temperature_effects import TemperatureDate
from vmapplet.tools.csv import ExprecCSV
from vmapplet.tools.rw_tools import ensureLocalDir, Recorder
from vmapplet.tools.file_tools import Cp_Lstring
from vmapplet.pipe import get_new_radius
from vmapplet.tools.dotdict import DotDict

options = {}
with io.open(get_shared_data('stocatree.toml')) as file:
    options = toml.load(file, _dict=DotDict)

extern (max_length = options.internode.max_length)
extern (min_length = options.internode.min_length)
extern (elongation_period = options.internode.elongation_period)
extern (plastochron = options.internode.plastochron)
options.internode.max_length = max_length
options.internode.min_length = min_length
options.internode.elongation_period = elongation_period
options.internode.plastochron = plastochron

extern (branching_angle = options.tree.branching_angle)
extern (phyllotactic_angle = options.tree.phyllotactic_angle)
options.tree.branching_angle = branching_angle
options.tree.phyllotactic_angle = phyllotactic_angle

extern (fruit_radius_per_kilo = 1.)

gravity = Vector3(0.0, 0.0, -9.81)

if options.general.pararun == True:
    output_directory = options.general.para_dir
else:
    if options.general.batchmode == True:
      output_directory = options.general.batch_dir
    else:
      output_directory = "Singlemode_ExpCounters&Results/"

ensureLocalDir(output_directory)

# Initialise the simulation
simulation = SimulationStocatree(dt=options.general.time_step,
  starting_date=int(options.general.starting_year),
  ending_date=options.general.end_year)

data = Data(options=options, init_date=simulation.date, directory=output_directory)

# Read PGLshape surfaces
stride = int(options.stocatree.stride_number)
leaf_surface = leafSurface(stride, stride)
ground_surface = groundSurface(stride, stride)
petal_surface = petalSurface(stride, stride)

# init markov and tree instances
markov = Markov(**options.markov)
markov.hsm_96_medium = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_5_15_y3_96.txt'))
markov.hsm_97_medium = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_5_15_y4_97.txt'))
markov.hsm_98_medium = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_5_15_y5_98.txt'))
markov.hsm_95_long = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_y12.txt'))
markov.hsm_96_long = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_16_65_y3_96.txt'))
markov.hsm_97_long = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_16_65_y4_97.txt'))
markov.hsm_98_long = HiddenSemiMarkov.ascii_read(StatError(), get_shared_data('fmodel_fuji_16_65_y5_98.txt'))

# The following objects (tree, wood, internode, apex_parameters, leaf, fruit
# are used to store the user parameters and are used by the metamer_data
# class to create new metamers. Tree is unique throughout the simulation, so
# only one instance is used.
# wood and internode are unique as well isnce they only contain parameters
# apices and leaves are specific to a metamer later on a deepcopy is used
tree = Tree(**options.tree)
wood = Wood(**options.wood)
internode = Internode(**options.internode)

# setup the colors once for all
colors = Colors()

#define the leaf area function once for all
simulation.func_leaf_area_init(get_shared_data('functions.fset'))

#define the range of leaf color to represent light interception
leaf_color_max = 96
leaf_color_min = 36

#define the date for light interception
interception_year = simulation.ending_date.year
interception_month = simulation.ending_date.month
interception_day = simulation.ending_date.day

#Here "itr_stp" is a counter to help in determining which step the light
# interception should occur at. Note that there are eight steps for using
# all the four l-system groups each time and there is no need to have the
# light interception at each step.
interception_step = 7
itr_stp = 0

# define the group enumerate here 0 used for rendering.
# physics and update_parameters inverse on purpose
initialisation    = 0
update_parameters = 1
update_structure  = 4
statistics        = 3
physics           = 2

module apex(apex_data): scale=2
module branch(): scale=1
module growth_unit(growth_unit_data): scale=1
module axiom()
module metamer(metamer_data): scale=2
module root(): scale=1

numerical_resolution_counter = 0

global norm

current_experiment = options.stocatree.select_trunk

if options.general.pararun == False:
    if options.general.batchmode == True:
        # Read the id of the current virtual experiment
        exp_rec = Recorder(output_directory + 'exp_recorder.h')
        exp_rec.read()
        current_experiment = exp_rec.content
    else:
        exp_rec = Recorder(output_directory + 'exp_recorder.h')
        exp_rec.read()
        previous_experiment = exp_rec.content
        if previous_experiment == '':
          previous_experiment = -1
        current_experiment = int(previous_experiment) + 1

stp = 0
trunk_len = 0
default_plastochron = options.internode.plastochron

def Start():

    tree = Tree(**options.tree)
    wood = Wood(**options.wood)
    internode = Internode(**options.internode)
    apex_parameters = {
        **options.apex,
        **options.markov
    }
    leaf_parameters = options.leaf
    fruit_parameters = options.fruit

    data.open_all(current_experiment)

    global trunk_len
    seq_op = open(get_shared_data("sequences.seq"))
    sequences = pickle.loads(seq_op.read().encode())
    for i in sequences[int(options.stocatree.select_trunk)]:
        if i != 9:
            trunk_len += 1

def StartEach():

    frameDisplay(True)

    global itr_stp

    if simulation.date.year in [1994,1995]:
        markov.hsm_medium = markov.hsm_96_medium
        markov.hsm_long   = markov.hsm_95_long
    elif simulation.date.year == 1996:
        markov.hsm_medium = markov.hsm_96_medium
        markov.hsm_long   = markov.hsm_96_long
    elif simulation.date.year == 1997:
        markov.hsm_medium = markov.hsm_97_medium
        markov.hsm_long   = markov.hsm_97_long
    else:
        markov.hsm_medium = markov.hsm_98_medium
        markov.hsm_long   = markov.hsm_98_long

    global bud_date
    global bud_break

    global growth_pause
    global sylleptic_year

    if options.temperature.temperature_effect == True:
        # This is used to calculate, at the beginning of each year, the date for bud break
        # in this year. Note that the year for onset of chilling effect should be one year
        # earlier than options.starting_year
        if simulation.date.month == 1 and simulation.date.day == 1:
            tp_dt = TemperatureDate(
                onset_year=simulation.date.year,
                optimal_temperature=options.temperature.optimal_temperature,
                chilling_effect_interval=options.temperature.chilling_effect_interval,
                chilling_effect_onset_month=options.temperature.chilling_effect_onset_month,
                chilling_effect_onset_day=options.temperature.chilling_effect_onset_day,
                chilling_quantity_required=options.temperature.chilling_quantity_required,
                characteristic_temperature=options.temperature.characteristic_temperature,
                heat_sigmoidal=options.temperature.heat_sigmoidal,
                sigmoidal_slope=options.temperature.sigmoidal_slope,
                heat_quantity_required=options.temperature.heat_quantity_required
            )
            bud_date = datetime(*tp_dt.bud_break())
        if simulation.date >= bud_date and simulation.date <= bud_date + timedelta(1):
            bud_break = True
        else:
            bud_break = False
    else:
        # If the temperature effect is off, the previous method developed by Cokelaer will be
        # used for calculating bud break date
        bud_break = simulation.events.bud_break.active

    if simulation.date.month >= options.general.pause_month:
        if simulation.date.day >= options.general.pause_day:
            growth_pause = True
        else:
            growth_pause = False
    else:
        growth_pause = False

    growth_days = 0
    if simulation.date.year == 1994:
        sylleptic_year = True
        growth_duration = date(1994, int(options.general.pause_month), int(options.general.pause_day)) \
            - date(bud_date.year, bud_date.month, bud_date.day)
        growth_days = growth_duration.days
        new_plastochron = 0 if trunk_len == 0 else int(math.floor(growth_days / trunk_len))
        if new_plastochron < default_plastochron:
            options.internode.plastochron = new_plastochron
            internode = Internode(**options.internode)
    else:
        # set plastochron with its default value if the year is not the sylleptic year
        options.internode.plastochron = default_plastochron
        internode = Internode(**options.internode)
        sylleptic_year = False

def EndEach(lstring,scene):

    global stp
    global itr_stp
    global current_experiment

    stp +=1

    if simulation.date > datetime.strptime(options.general.end_year, "%Y-%m-%d"):
        Stop()
        End(lstring,scene)

    # This switch controls the selection of which group of productions to apply.
    # The general sequence is:
    #
    #   initialisation --> update parameters --> output (L-string or MTG) -->
    #   physics --> statistics --> update structure --> update parameters
    #
    # Rendering happens after 'update parameters'. 'output' is only
    # called conditionally; mostly, the simulation goes straight from
    # 'output parameters' to 'physics'
    if simulation.phase == initialisation:
        useGroup(update_parameters)
        simulation.phase = update_parameters
        frameDisplay(False)
    elif simulation.phase == update_parameters:
        global numerical_resolution_counter
        numerical_resolution_counter += 1
        if numerical_resolution_counter < simulation.rotation_convergence.steps:
            simulation.dt = 0.0 # days
            frameDisplay(False)
        else:
            simulation.dt = simulation.base_dt
            numerical_resolution_counter = 0
        newyear = simulation.advance()
        if simulation.events.harvest.active:
            tree.fruits_harvested = tree.fruits
            tree.fruits = 0
            simulation.harvested = True
        if options.output.trunk:
            data.trunk.save(simulation.date, tree.trunk_radius,tree.trunk_cross_sectional_area)
        useGroup(physics)
        simulation.phase = physics
        backward()
    elif simulation.phase == statistics:
        useGroup(update_structure)
        simulation.phase = update_structure
        frameDisplay(False)
    elif simulation.phase == physics:
        useGroup(statistics)
        simulation.phase = statistics
        forward()
        frameDisplay(False)
    elif simulation.phase == update_structure:
        useGroup(update_parameters)
        simulation.phase = update_parameters
        frameDisplay(False)
    else:
        raise ValueError(f'Simulation phase {simulation.phase} unkown.')

def End(lstring,scene):

    global data
    data.close_all()
    data.save()

    if not options.general.pararun:
        if not options.general.batchmode == False:
            exp_rec = open(output_directory + 'exp_recorder.h', 'w')
            exp_rec.write('%u' % current_experiment)
            exp_rec.close()
        sc = Recorder(output_directory + "exp_successful.h")
        sc.write(str(current_experiment))


derivation length: int(options.general.max_iterations)

Axiom: axiom()

ignore: growth_unit

production:

# The L-system starts with this group.  If there were any errors in the
# initialisations in Start, produce an error message, otherwise, start the simulation.
group 0:

axiom():
    apex_parameters = {
        **options.apex,
        **options.markov
    }
    produce apex(ApexData(tree.initial_hlu, 'trunk', **apex_parameters))


# Update the parameters of each metamer (age, reaction wood, organs, length,
# rigidity & shape memory) and perform the geometric reconstruction
# (rotation and placement of each metamer)
group 1:

metamer(ml) branch() << metamer(m):
    m.update_metamer_parameters(simulation)
    m.organ_activity(simulation)
    if options.stocatree.mechanics:
        m.hlu = rotate_frame_at_branch(ml.hlu, ml.branching_angle,  ml.phyllotactic_angle);
        m.hlu = optimisation.reorient_frame(m.hlu, m.rotation_velocity, m.rv_norm, m.length)
    m.update_position(ml.position)
    produce metamer(m)

metamer(ml) << metamer(m):
    m.update_metamer_parameters(simulation)
    m.organ_activity(simulation)
    if options.stocatree.mechanics:
        m.hlu = optimisation.reorient_frame(ml.hlu, m.rotation_velocity, m.rv_norm, m.length)
    m.update_position(ml.position)
    produce metamer(m)

metamer(m):
    m.update_metamer_parameters(simulation)
    m.organ_activity(simulation)
    m.update_position()
    produce metamer(m)


# Calculate the width (by the pipe model), cumulated mass, cumulated torque and
# rotation velocity of each metamer
group 2: #  physics

root() >> metamer(m):
    tree.trunk_radius = m.radius
    tree.trunk_cross_sectional_area = constants.pi * m.radius * m.radius
    tree.fruit_load = tree.fruits / tree.trunk_cross_sectional_area

metamer(m) >> SB() branch() metamer(mb) EB() metamer(mr):
    radius = optimisation.get_new_radius(mb.radius, mr.radius)
    if m.leaf.state=='growing':
        radius = optimisation.get_new_radius(radius, m.leaf.petiole_radius)
    m.radius = optimisation.max(radius, m.radius);
    # update last layer thickness
    m.layers[-1].thickness = m.radius - m.layers[-1].radius
    m.compute_mass(mr, mb)
    # cumulated torque cumulate mass must be in kg
    if options.stocatree.mechanics:
        m.cumulated_torque = (
            mb.cumulated_torque + mr.cumulated_torque \
            + cross((mb.hlu.heading * mb.length), (gravity * mb.cumulated_mass)) \
            + cross((mr.hlu.heading * mr.length), (gravity * mr.cumulated_mass))\
            + cross((m.hlu.heading * m.length) , tree.tropism)
        )
        m.calculate_rotation_velocity(simulation, options.stocatree.stake)
    produce metamer(m)

metamer(m) >> metamer(mr):
    radius = mr.radius
    if m.leaf.state == 'growing':
        radius = optimisation.get_new_radius(mr.radius, m.leaf.petiole_radius)
    m.radius = optimisation.max(radius, m.radius)
    m.layers[-1].thickness = m.radius - m.layers[-1].radius
    m.compute_mass(mr)
    if options.stocatree.mechanics:
        m.cumulated_torque = (
            cross((mr.hlu.heading * mr.length), (gravity * mr.cumulated_mass)) \
            + mr.cumulated_torque \
            + cross((m.hlu.heading * m.length) , tree.tropism)
        )
        m.calculate_rotation_velocity(simulation, options.stocatree.stake)
    produce metamer(m)

metamer(m) >> apex(a):
    # wood.density, m.fruit_mass are units objects
    radius = a.radius
    if m.leaf.state=='growing':
        radius = optimisation.get_new_radius(a.radius, m.leaf.petiole_radius)
    m.radius = optimisation.max(radius, m.radius);
    m.layers[-1].thickness = m.radius - m.layers[-1].radius
    m.compute_mass()
    m.cumulated_torque = cross( m.hlu.heading * m.length , tree.tropism)
    if options.stocatree.mechanics:
        m.calculate_rotation_velocity(simulation, options.stocatree.stake)
    produce metamer(m)

apex(a):
    if a.sequence_position == 0 and a.radius < a.target_radius:
        a.terminal_expansion(simulation.dt.days)
    produce apex(a)


# Generate new sequences
group 3: # group statistics

apex(a):
    if a.sequence_position == 0 and a.get_observation()!='dormant' and (a.parent_observation == 'floral' or bud_break or (sylleptic_year and a.year < simulation.date.year and (a.get_observation() == 'small' or a.get_observation() == 'medium' or a.get_observation() == 'large'))):
        old_observation = a.get_observation()
        a.parent_observation = old_observation
        if a.parent_observation == 'sylleptic_short':
            a.parent_observation = 'small'
            a.set_observation('small')
        elif a.parent_observation == 'sylleptic_medium':
            a.parent_observation = 'medium'
            a.set_observation('medium')
        elif a.parent_observation == 'sylleptic_large':
            a.parent_observation = 'large'
            a.set_observation('large')
        a.sequence  = generate_sequence(
            a.get_observation(),
            markov, simulation.date.year, options.stocatree.second_year_draws,
            select_trunk=[int(options.stocatree.select_trunk)]
        )
        a.sequence_position = len(a.sequence)
        if a.get_observation() == 'trunk':
            a.set_observation('large')
        elif a.get_observation() =='small' and boolean_event(tree.spur_death_probability):
            a.set_observation('dormant')
        elif a.get_observation()=='floral':
            a.set_observation('dormant')
        else:
            a.set_observation(terminal_fate(simulation.date.year,a.get_observation()))
        a.radius = 0
        a.max_terminal_radius_target()
        tree.growth_units += 1
        # record the unit id that this apex belongs to (the id values start from 0)
        a.parent_unit_id = tree.growth_units-1
        # update counts
        if options.output.counts:
            if a.parent_observation=='floral':
                data.counts.florals += 1
            elif a.parent_observation == 'small':
                data.counts.shorts += 1
            elif a.parent_observation == 'medium':
                data.counts.mediums += 1
            elif a.parent_observation == 'large':
                data.counts.longs += 1
                if a.sequence_position < 26:
                    data.counts.len_16_to_25 += 1
                elif a.sequence_position < 41:
                    data.counts.len_26_to_40+=1
                else:
                    data.counts.len_over_40+=1
        # save sequences into output data
        if options.output.sequences and simulation.date.year < 1999 and (a.parent_observation in ['large', 'medium', 'small']):
            data.sequences.save(a.sequence, a.sequence_position)
        # Note that a.year was initially smaller than simulation.date.year
        # Once a growth unit is finished, a.year will be set as the same
        # This is to avoid the production of two growth units at the same axis
        # at the same year
        a.year = simulation.date.year
        nproduce growth_unit(GrowthUnitData(tree.growth_units, simulation.date.year, a.parent_observation == 'floral')) apex(a)
    else:
        produce apex(a)

# Add new apices (terminal and lateral) and metamers to the structure
group 4: # group update_structure

metamer(m) < apex(a):
    if a.sequence_position > 0 and m.age >= options.internode.plastochron:
        a.sequence_position -= 1
        flower = a.sequence_position == 0 and a.parent_observation=='floral'
        if m.year == simulation.date.year:
            number = m.number + 1
        else:
            number = 1
        leaf_parameters = options.leaf
        fruit_parameters = options.fruit
        mn = MetamerData(
            floral=flower,
            number=number,
            hlu=a.hlu,
            zone=a.sequence[a.sequence_position][0],
            observation=a.get_observation_from_sequence(),
            parent_observation=a.parent_observation,
            parent_unit_id=a.parent_unit_id,
            parent_fbr_id=a.parent_fbr_id,
            parent_tree_id=a.parent_tree_id,
            p_angle=m.phyllotactic_angle + tree.phyllotactic_angle,
            b_angle=tree.branching_angle, wood=wood, internode=internode,
            fruit=AppleFruit(**fruit_parameters),
            leaf=AppleLeaf(**leaf_parameters)
        )
        mn.trunk = a.trunk
        mn.year = simulation.date.year
        mn.sylleptic = a.sylleptic
        if not growth_pause:
            produce metamer(mn) apex(a)
        else:
            a.sequence_position = 0
            produce apex(a)
    else:
        produce apex(a)


apex(a):
    if a.sequence_position > 0:
        a.sequence_position -= 1
        branching_angle = tree.branching_angle;
        flower = a.sequence_position == 0 and a.parent_observation=='floral'
        leaf_parameters = options.leaf
        fruit_parameters = options.fruit
        m = MetamerData(
            floral=flower,
            number=1,
            hlu=a.hlu,
            zone=a.sequence[a.sequence_position][0],
            observation=a.get_observation_from_sequence(),
            parent_observation= a.parent_observation,
            parent_unit_id=a.parent_unit_id,
            parent_fbr_id=a.parent_fbr_id,
            parent_tree_id=a.parent_tree_id,
            p_angle=tree.phyllotactic_angle,
            b_angle=branching_angle,
            wood=wood,
            internode=internode,
            fruit=AppleFruit(**fruit_parameters),
            leaf=AppleLeaf(**leaf_parameters)
        )
        m.trunk = a.trunk
        m.year = simulation.date.year
        m.sylleptic = a.sylleptic
        if not growth_pause:
            produce metamer(m) apex(a)
        else:
            a.sequence_position = 0
            produce apex(a)
    else:
        produce apex(a)

metamer(m) > metamer(mr) apex(a):
    # case of a floral immediate lateral axis: should be treated as laterals and not as terminals
    if not m.developped and a.parent_observation == 'floral' and a.sequence_position == 0:
        m.developped = True
        if boolean_event(tree.inflorescence_death_probability):
            produce metamer(m)
        m.branching_angle = tree.floral_branching_angle
        hlu = rotate_frame_at_branch(m.hlu, m.branching_angle, m.phyllotactic_angle);
        apex_parameters = {
            **options.apex,
            **options.markov
        }
        sylleptic_apex = ApexData(hlu, terminal_fate(simulation.date.year, 'floral'), **apex_parameters)
        sylleptic_apex.parent_observation = 'floral'
        if m.parent_fbr_id == 0:
            tree.first_branches += 1
            # The parent_fbr_id ranges from 0 to tree.first_branches (rather than to tree.frist-branches-1)
            # This is because, the trunk is regarded by branch 0 as default
            # Thus the id of the first real branch should be 1
            sylleptic_apex.parent_fbr_id = tree.first_branches
        else:
            sylleptic_apex.parent_fbr_id = m.parent_fbr_id
        produce metamer(m) SB() branch() apex(sylleptic_apex) EB()

metamer(m):
    if options.stocatree.ruptures and rupture(m.cumulated_torque, m.radius, wood._modulus_of_rupture):
        print('EXTRAORDINARY EVENT: There was a rupture in the system.\n')
        produce Label('Cut') Cut()
    if m.observation!= 'dormant' and  not m.developped and (bud_break or ((m.observation == 'small' or m.observation == 'medium' or m.observation == 'large') and m.parent_observation == "trunk" and m.sylleptic == True)):
        m.developped = True
        hlu = rotate_frame_at_branch(m.hlu, m.branching_angle, m.phyllotactic_angle)
        apex_parameters = {
            **options.apex,
            **options.markov
        }
        a = ApexData(hlu, m.observation, **apex_parameters)
        if m.parent_fbr_id == 0:
            tree.first_branches +=1
            # The parent_fbr_id ranges from 0 to tree.first_branches (rather than to tree.frist-branches-1)
            # This is because, the trunk is regarded by branch 0 as default
            # Thus the id of the first real branch should be 1
            a.parent_fbr_id = tree.first_branches
        else:
            a.parent_fbr_id = m.parent_fbr_id
        produce metamer(m) SB() branch() apex(a) EB()
    else:
        produce metamer(m)


# Graphical rendering of the tree
group 0:
interpretation:

root():
    dateLabel = str(simulation.date.year) + '-' + str(simulation.date.month) + '-' + str(simulation.date.day)
    produce SB() f(-3) SetColor(colors.background) Label(dateLabel) f(3) SetColor(colors.ground) PglShape(ground_surface, 10.0) EB();

metamer(m):
    shoot_colour = colors.error
    if options.stocatree.render_mode == 'bark':
        shoot_colour = colors.bark
    elif options.stocatree.render_mode == 'observations':
        shoot_colour = colors.observation.get_color(m.observation)
    elif options.stocatree.render_mode == 'zones':
        shoot_colour = colors.zone.get_color(m.zone)
    elif options.stocatree.render_mode == 'reaction_wood':
        shoot_colour = colors.reaction_wood.get_color(m.layers[-1].reaction_wood)
    elif options.stocatree.render_mode == 'year':
        shoot_colour = colors.year.get_color(m.year, options.general.starting_year)
    nproduce SetHead(m.hlu.heading.x, m.hlu.heading.y, m.hlu.heading.z, m.hlu.up.x, m.hlu.up.y, m.hlu.up.z)
    nproduce SetWidth(m.radius*10) SetColor(shoot_colour) F(m.length*10)
    d2r = 180.0 / constants.pi
    if (m.fruit.state == 'flower'):
        scale = 5.
        nproduce SB() RollL(m.phyllotactic_angle * d2r)
        nproduce Up(45)
        nproduce SetColor(colors.stamen)
        nproduce SetWidth(0.0025 * scale)
        nproduce SB()
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB() RollL(72.0)
        nproduce SB() Up(15) F(0.0125) EB()
        nproduce EB()
        nproduce SetColor(colors.petal)
        nproduce PglShape(petal_surface, 0.02 * scale) RollL(144.0)
        nproduce PglShape(petal_surface, 0.02 * scale) RollL(144.0)
        nproduce PglShape(petal_surface, 0.02 * scale) RollL(144.0)
        nproduce PglShape(petal_surface, 0.02 * scale) RollL(144.0)
        nproduce PglShape(petal_surface, 0.02 * scale)
        nproduce EB()
    elif (m.fruit.state == 'fruit'):
        r = m.fruit.mass * fruit_radius_per_kilo
        if r != 0:
            nproduce SB() RollL(float(m.phyllotactic_angle * d2r))
            nproduce Down(90.0) f(r) SetColor(colors.fruit) Sphere(r) EB()
    if m.leaf.state == 'growing':
        r = m.leaf.mass * 1000.
        if r==0:
            r=0.1
        norm = 0.3
        colors.leaf = 15
        colors.leaf = 15
        if m.leaf.lg == 0:
            colors.leaf =15
        # check max total mass should be less than 0.66 grams
        if simulation.events.autumn.active is False:
            nproduce SB() SetColor(colors.leaf)
        else:
            nproduce SB() SetColor(colors.autumn_leaf)
        r = math.sqrt(m.leaf_area / 0.006154)
        if r > 0:
            nproduce (RollL(m.phyllotactic_angle * d2r)  +(90) SetWidth(0.002) F(r * 0.1)   PglShape(leaf_surface, r) +(-90) EB())
        else:
            nproduce EB()
    produce

endgroup
homomorphism:

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
    import openalea.plantgl.all as pgl
    Color_0 = pgl.Material("Color_0" , ambient = (19,19,19) , diffuse = 0 , )
    Color_0.name = "Color_0"
    context.turtle.setMaterial(0,Color_0)
    Color_1 = pgl.Material("Color_1" , ambient = (255,0,0) , diffuse = 1 , )
    Color_1.name = "Color_1"
    context.turtle.setMaterial(1,Color_1)
    Color_2 = pgl.Material("Color_2" , ambient = (0,35,35) , diffuse = 7.28571 , )
    Color_2.name = "Color_2"
    context.turtle.setMaterial(2,Color_2)
    Color_3 = pgl.Material("Color_3" , ambient = (0,0,27) , diffuse = 9.44444 , )
    Color_3.name = "Color_3"
    context.turtle.setMaterial(3,Color_3)
    Color_4 = pgl.Material("Color_4" , ambient = (51,0,51) , diffuse = 5 , )
    Color_4.name = "Color_4"
    context.turtle.setMaterial(4,Color_4)
    Color_5 = pgl.Material("Color_5" , ambient = (18,0,0) , diffuse = 14.1111 , specular = (0,0,0) , )
    Color_5.name = "Color_5"
    context.turtle.setMaterial(5,Color_5)
    Color_6 = pgl.Material("Color_6" , ambient = (45,45,0) , diffuse = 5.17778 , specular = (49,23,9) , )
    Color_6.name = "Color_6"
    context.turtle.setMaterial(6,Color_6)
    Color_7 = pgl.Material("Color_7" , ambient = (0,29,29) , diffuse = 8.7931 , )
    Color_7.name = "Color_7"
    context.turtle.setMaterial(7,Color_7)
    Color_8 = pgl.Material("Color_8" , ambient = (0,31,0) , diffuse = 2.67742 , )
    Color_8.name = "Color_8"
    context.turtle.setMaterial(8,Color_8)
    Color_9 = pgl.Material("Color_9" , ambient = (41,41,0) , diffuse = 6.21951 , specular = (0,0,0) , )
    Color_9.name = "Color_9"
    context.turtle.setMaterial(9,Color_9)
    Color_10 = pgl.Material("Color_10" , ambient = (41,0,0) , diffuse = 6.21951 , )
    Color_10.name = "Color_10"
    context.turtle.setMaterial(10,Color_10)
    Color_11 = pgl.Material("Color_11" , ambient = (30,0,30) , diffuse = 8.5 , )
    Color_11.name = "Color_11"
    context.turtle.setMaterial(11,Color_11)
    Color_12 = pgl.Material("Color_12" , ambient = (0,0,31) , diffuse = 8.22581 , )
    Color_12.name = "Color_12"
    context.turtle.setMaterial(12,Color_12)
    Color_13 = pgl.Material("Color_13" , ambient = (45,45,45) , diffuse = 5.66667 , )
    Color_13.name = "Color_13"
    context.turtle.setMaterial(13,Color_13)
    Color_14 = pgl.Material("Color_14" , ambient = (63,12,13) , diffuse = 1.57143 , specular = (51,44,0) , emission = (8,8,8) , shininess = 0.47 , )
    Color_14.name = "Color_14"
    context.turtle.setMaterial(14,Color_14)
    Color_15 = pgl.Material("Color_15" , ambient = (0,59,6) , diffuse = 1.59322 , )
    Color_15.name = "Color_15"
    context.turtle.setMaterial(15,Color_15)
    Color_16 = pgl.Material("Color_16" , ambient = (29,7,6) , diffuse = 4.41379 , specular = (37,95,28) , )
    Color_16.name = "Color_16"
    context.turtle.setMaterial(16,Color_16)
    Color_17 = pgl.Material("Color_17" , ambient = (107,59,54) , diffuse = 1.91589 , transparency = 0.17 , )
    Color_17.name = "Color_17"
    context.turtle.setMaterial(17,Color_17)
    Color_18 = pgl.Material("Color_18" , ambient = (82,64,45) , diffuse = 2.56098 , specular = (0,0,0) , shininess = 0 , )
    Color_18.name = "Color_18"
    context.turtle.setMaterial(18,Color_18)
    Color_19 = pgl.Material("Color_19" , ambient = (49,29,25) , diffuse = 2.55102 , specular = (0,0,0) , shininess = 0 , )
    Color_19.name = "Color_19"
    context.turtle.setMaterial(19,Color_19)
    Color_20 = pgl.Material("Color_20" , ambient = (0,85,0) , diffuse = 1.38824 , )
    Color_20.name = "Color_20"
    context.turtle.setMaterial(20,Color_20)
    Color_34 = pgl.Material("Color_34" , ambient = (0,218,32) , diffuse = 0.733945 , )
    Color_34.name = "Color_34"
    context.turtle.setMaterial(34,Color_34)
    Color_35 = pgl.Material("Color_35" , ambient = (0,1,21) , diffuse = 8.14286 , )
    Color_35.name = "Color_35"
    context.turtle.setMaterial(35,Color_35)
    Color_36 = pgl.Material("Color_36" , ambient = (25,0,255) , diffuse = 0 , specular = (0,0,0) , )
    Color_36.name = "Color_36"
    context.turtle.setMaterial(36,Color_36)
    Color_37 = pgl.Material("Color_37" , ambient = (28,0,250) , diffuse = 0 , specular = (0,0,0) , )
    Color_37.name = "Color_37"
    context.turtle.setMaterial(37,Color_37)
    Color_38 = pgl.Material("Color_38" , ambient = (32,0,246) , diffuse = 0 , specular = (0,0,0) , )
    Color_38.name = "Color_38"
    context.turtle.setMaterial(38,Color_38)
    Color_39 = pgl.Material("Color_39" , ambient = (36,0,242) , diffuse = 0 , specular = (0,0,0) , )
    Color_39.name = "Color_39"
    context.turtle.setMaterial(39,Color_39)
    Color_40 = pgl.Material("Color_40" , ambient = (40,0,238) , diffuse = 0 , specular = (0,0,0) , )
    Color_40.name = "Color_40"
    context.turtle.setMaterial(40,Color_40)
    Color_41 = pgl.Material("Color_41" , ambient = (44,0,234) , diffuse = 0 , specular = (0,0,0) , )
    Color_41.name = "Color_41"
    context.turtle.setMaterial(41,Color_41)
    Color_42 = pgl.Material("Color_42" , ambient = (48,0,229) , diffuse = 0 , specular = (0,0,0) , )
    Color_42.name = "Color_42"
    context.turtle.setMaterial(42,Color_42)
    Color_43 = pgl.Material("Color_43" , ambient = (51,0,225) , diffuse = 0 , specular = (0,0,0) , )
    Color_43.name = "Color_43"
    context.turtle.setMaterial(43,Color_43)
    Color_44 = pgl.Material("Color_44" , ambient = (55,0,221) , diffuse = 0 , specular = (0,0,0) , )
    Color_44.name = "Color_44"
    context.turtle.setMaterial(44,Color_44)
    Color_45 = pgl.Material("Color_45" , ambient = (101,0,171) , diffuse = 0 , specular = (0,0,0) , )
    Color_45.name = "Color_45"
    context.turtle.setMaterial(45,Color_45)
    Color_46 = pgl.Material("Color_46" , ambient = (63,0,213) , diffuse = 0 , specular = (0,0,0) , )
    Color_46.name = "Color_46"
    context.turtle.setMaterial(46,Color_46)
    Color_47 = pgl.Material("Color_47" , ambient = (67,0,208) , diffuse = 0 , specular = (0,0,0) , )
    Color_47.name = "Color_47"
    context.turtle.setMaterial(47,Color_47)
    Color_48 = pgl.Material("Color_48" , ambient = (71,0,204) , diffuse = 0 , specular = (0,0,0) , )
    Color_48.name = "Color_48"
    context.turtle.setMaterial(48,Color_48)
    Color_49 = pgl.Material("Color_49" , ambient = (74,0,200) , diffuse = 0 , specular = (0,0,0) , )
    Color_49.name = "Color_49"
    context.turtle.setMaterial(49,Color_49)
    Color_50 = pgl.Material("Color_50" , ambient = (78,0,196) , diffuse = 0 , specular = (0,0,0) , )
    Color_50.name = "Color_50"
    context.turtle.setMaterial(50,Color_50)
    Color_51 = pgl.Material("Color_51" , ambient = (82,0,192) , diffuse = 0 , specular = (0,0,0) , )
    Color_51.name = "Color_51"
    context.turtle.setMaterial(51,Color_51)
    Color_52 = pgl.Material("Color_52" , ambient = (86,0,188) , diffuse = 0 , specular = (0,0,0) , )
    Color_52.name = "Color_52"
    context.turtle.setMaterial(52,Color_52)
    Color_53 = pgl.Material("Color_53" , ambient = (90,0,183) , diffuse = 0 , specular = (0,0,0) , )
    Color_53.name = "Color_53"
    context.turtle.setMaterial(53,Color_53)
    Color_54 = pgl.Material("Color_54" , ambient = (94,0,179) , diffuse = 0 , specular = (0,0,0) , )
    Color_54.name = "Color_54"
    context.turtle.setMaterial(54,Color_54)
    Color_55 = pgl.Material("Color_55" , ambient = (97,0,175) , diffuse = 0 , specular = (0,0,0) , )
    Color_55.name = "Color_55"
    context.turtle.setMaterial(55,Color_55)
    Color_56 = pgl.Material("Color_56" , ambient = (59,0,217) , diffuse = 0 , specular = (0,0,0) , )
    Color_56.name = "Color_56"
    context.turtle.setMaterial(56,Color_56)
    Color_57 = pgl.Material("Color_57" , ambient = (105,0,167) , diffuse = 0 , specular = (0,0,0) , )
    Color_57.name = "Color_57"
    context.turtle.setMaterial(57,Color_57)
    Color_58 = pgl.Material("Color_58" , ambient = (109,0,162) , diffuse = 0 , specular = (0,0,0) , )
    Color_58.name = "Color_58"
    context.turtle.setMaterial(58,Color_58)
    Color_59 = pgl.Material("Color_59" , ambient = (113,0,158) , diffuse = 0 , specular = (0,0,0) , )
    Color_59.name = "Color_59"
    context.turtle.setMaterial(59,Color_59)
    Color_60 = pgl.Material("Color_60" , ambient = (116,0,154) , diffuse = 0 , specular = (0,0,0) , )
    Color_60.name = "Color_60"
    context.turtle.setMaterial(60,Color_60)
    Color_61 = pgl.Material("Color_61" , ambient = (120,0,150) , diffuse = 0 , specular = (0,0,0) , )
    Color_61.name = "Color_61"
    context.turtle.setMaterial(61,Color_61)
    Color_62 = pgl.Material("Color_62" , ambient = (124,0,146) , diffuse = 0 , specular = (0,0,0) , )
    Color_62.name = "Color_62"
    context.turtle.setMaterial(62,Color_62)
    Color_63 = pgl.Material("Color_63" , ambient = (128,0,142) , diffuse = 0 , specular = (0,0,0) , )
    Color_63.name = "Color_63"
    context.turtle.setMaterial(63,Color_63)
    Color_64 = pgl.Material("Color_64" , ambient = (132,0,137) , diffuse = 0 , specular = (0,0,0) , )
    Color_64.name = "Color_64"
    context.turtle.setMaterial(64,Color_64)
    Color_65 = pgl.Material("Color_65" , ambient = (136,0,133) , diffuse = 0 , specular = (0,0,0) , )
    Color_65.name = "Color_65"
    context.turtle.setMaterial(65,Color_65)
    Color_66 = pgl.Material("Color_66" , ambient = (140,0,129) , diffuse = 0 , specular = (0,0,0) , )
    Color_66.name = "Color_66"
    context.turtle.setMaterial(66,Color_66)
    Color_67 = pgl.Material("Color_67" , ambient = (143,0,125) , diffuse = 0 , specular = (0,0,0) , )
    Color_67.name = "Color_67"
    context.turtle.setMaterial(67,Color_67)
    Color_68 = pgl.Material("Color_68" , ambient = (147,0,121) , diffuse = 0 , specular = (0,0,0) , )
    Color_68.name = "Color_68"
    context.turtle.setMaterial(68,Color_68)
    Color_69 = pgl.Material("Color_69" , ambient = (151,0,116) , diffuse = 0 , specular = (0,0,0) , )
    Color_69.name = "Color_69"
    context.turtle.setMaterial(69,Color_69)
    Color_70 = pgl.Material("Color_70" , ambient = (155,0,112) , diffuse = 0 , specular = (0,0,0) , )
    Color_70.name = "Color_70"
    context.turtle.setMaterial(70,Color_70)
    Color_71 = pgl.Material("Color_71" , ambient = (159,0,108) , diffuse = 0 , specular = (0,0,0) , )
    Color_71.name = "Color_71"
    context.turtle.setMaterial(71,Color_71)
    Color_72 = pgl.Material("Color_72" , ambient = (163,0,104) , diffuse = 0 , specular = (0,0,0) , )
    Color_72.name = "Color_72"
    context.turtle.setMaterial(72,Color_72)
    Color_73 = pgl.Material("Color_73" , ambient = (166,0,100) , diffuse = 0 , specular = (0,0,0) , )
    Color_73.name = "Color_73"
    context.turtle.setMaterial(73,Color_73)
    Color_74 = pgl.Material("Color_74" , ambient = (170,0,96) , diffuse = 0 , specular = (0,0,0) , )
    Color_74.name = "Color_74"
    context.turtle.setMaterial(74,Color_74)
    Color_75 = pgl.Material("Color_75" , ambient = (174,0,91) , diffuse = 0 , specular = (0,0,0) , )
    Color_75.name = "Color_75"
    context.turtle.setMaterial(75,Color_75)
    Color_76 = pgl.Material("Color_76" , ambient = (178,0,87) , diffuse = 0 , specular = (0,0,0) , )
    Color_76.name = "Color_76"
    context.turtle.setMaterial(76,Color_76)
    Color_77 = pgl.Material("Color_77" , ambient = (182,0,83) , diffuse = 0 , specular = (0,0,0) , )
    Color_77.name = "Color_77"
    context.turtle.setMaterial(77,Color_77)
    Color_78 = pgl.Material("Color_78" , ambient = (186,0,79) , diffuse = 0 , specular = (0,0,0) , )
    Color_78.name = "Color_78"
    context.turtle.setMaterial(78,Color_78)
    Color_79 = pgl.Material("Color_79" , ambient = (189,0,75) , diffuse = 0 , specular = (0,0,0) , )
    Color_79.name = "Color_79"
    context.turtle.setMaterial(79,Color_79)
    Color_80 = pgl.Material("Color_80" , ambient = (193,0,70) , diffuse = 0 , specular = (0,0,0) , )
    Color_80.name = "Color_80"
    context.turtle.setMaterial(80,Color_80)
    Color_81 = pgl.Material("Color_81" , ambient = (197,0,66) , diffuse = 0 , specular = (0,0,0) , )
    Color_81.name = "Color_81"
    context.turtle.setMaterial(81,Color_81)
    Color_82 = pgl.Material("Color_82" , ambient = (201,0,62) , diffuse = 0 , specular = (0,0,0) , )
    Color_82.name = "Color_82"
    context.turtle.setMaterial(82,Color_82)
    Color_83 = pgl.Material("Color_83" , ambient = (205,0,58) , diffuse = 0 , specular = (0,0,0) , )
    Color_83.name = "Color_83"
    context.turtle.setMaterial(83,Color_83)
    Color_84 = pgl.Material("Color_84" , ambient = (209,0,54) , diffuse = 0 , specular = (0,0,0) , )
    Color_84.name = "Color_84"
    context.turtle.setMaterial(84,Color_84)
    Color_85 = pgl.Material("Color_85" , ambient = (212,0,50) , diffuse = 0 , specular = (0,0,0) , )
    Color_85.name = "Color_85"
    context.turtle.setMaterial(85,Color_85)
    Color_86 = pgl.Material("Color_86" , ambient = (216,0,45) , diffuse = 0 , specular = (0,0,0) , )
    Color_86.name = "Color_86"
    context.turtle.setMaterial(86,Color_86)
    Color_87 = pgl.Material("Color_87" , ambient = (220,0,41) , diffuse = 0 , specular = (0,0,0) , )
    Color_87.name = "Color_87"
    context.turtle.setMaterial(87,Color_87)
    Color_88 = pgl.Material("Color_88" , ambient = (224,0,37) , diffuse = 0 , specular = (0,0,0) , )
    Color_88.name = "Color_88"
    context.turtle.setMaterial(88,Color_88)
    Color_89 = pgl.Material("Color_89" , ambient = (228,0,33) , diffuse = 0 , specular = (0,0,0) , )
    Color_89.name = "Color_89"
    context.turtle.setMaterial(89,Color_89)
    Color_90 = pgl.Material("Color_90" , ambient = (232,0,29) , diffuse = 0 , specular = (0,0,0) , )
    Color_90.name = "Color_90"
    context.turtle.setMaterial(90,Color_90)
    Color_91 = pgl.Material("Color_91" , ambient = (235,0,24) , diffuse = 0 , specular = (0,0,0) , )
    Color_91.name = "Color_91"
    context.turtle.setMaterial(91,Color_91)
    Color_92 = pgl.Material("Color_92" , ambient = (239,0,20) , diffuse = 0 , specular = (0,0,0) , )
    Color_92.name = "Color_92"
    context.turtle.setMaterial(92,Color_92)
    Color_93 = pgl.Material("Color_93" , ambient = (243,0,16) , diffuse = 0 , specular = (0,0,0) , )
    Color_93.name = "Color_93"
    context.turtle.setMaterial(93,Color_93)
    Color_94 = pgl.Material("Color_94" , ambient = (247,0,12) , diffuse = 0 , specular = (0,0,0) , )
    Color_94.name = "Color_94"
    context.turtle.setMaterial(94,Color_94)
    Color_95 = pgl.Material("Color_95" , ambient = (251,0,8) , diffuse = 0 , specular = (0,0,0) , )
    Color_95.name = "Color_95"
    context.turtle.setMaterial(95,Color_95)
    Color_96 = pgl.Material("Color_96" , ambient = (255,0,4) , diffuse = 0 , specular = (0,0,0) , )
    Color_96.name = "Color_96"
    context.turtle.setMaterial(96,Color_96)
    Color_97 = pgl.Material("Color_97" , ambient = (255,0,0) , diffuse = 0.619608 , )
    Color_97.name = "Color_97"
    context.turtle.setMaterial(97,Color_97)
    Color_98 = pgl.Material("Color_98" , ambient = (149,0,0) , diffuse = 1.0604 , )
    Color_98.name = "Color_98"
    context.turtle.setMaterial(98,Color_98)
    Color_99 = pgl.Material("Color_99" , ambient = (156,0,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_99.name = "Color_99"
    context.turtle.setMaterial(99,Color_99)
    Color_100 = pgl.Material("Color_100" , ambient = (165,24,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_100.name = "Color_100"
    context.turtle.setMaterial(100,Color_100)
    Color_101 = pgl.Material("Color_101" , ambient = (175,49,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_101.name = "Color_101"
    context.turtle.setMaterial(101,Color_101)
    Color_102 = pgl.Material("Color_102" , ambient = (185,74,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_102.name = "Color_102"
    context.turtle.setMaterial(102,Color_102)
    Color_103 = pgl.Material("Color_103" , ambient = (195,98,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_103.name = "Color_103"
    context.turtle.setMaterial(103,Color_103)
    Color_104 = pgl.Material("Color_104" , ambient = (205,123,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_104.name = "Color_104"
    context.turtle.setMaterial(104,Color_104)
    Color_105 = pgl.Material("Color_105" , ambient = (215,148,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_105.name = "Color_105"
    context.turtle.setMaterial(105,Color_105)
    Color_106 = pgl.Material("Color_106" , ambient = (225,172,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_106.name = "Color_106"
    context.turtle.setMaterial(106,Color_106)
    Color_107 = pgl.Material("Color_107" , ambient = (235,197,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_107.name = "Color_107"
    context.turtle.setMaterial(107,Color_107)
    Color_108 = pgl.Material("Color_108" , ambient = (245,222,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_108.name = "Color_108"
    context.turtle.setMaterial(108,Color_108)
    Color_109 = pgl.Material("Color_109" , ambient = (255,247,0) , diffuse = 0 , specular = (0,0,0) , )
    Color_109.name = "Color_109"
    context.turtle.setMaterial(109,Color_109)
    context.animation_timestep = 0.0
    context.options.setSelection('Module declaration',1)
    context.options.setSelection('Module matching',0)
    context.options.setSelection('Early return when no matching',0)
    context.options.setSelection('Warning with Turtle inconsistency',0)
